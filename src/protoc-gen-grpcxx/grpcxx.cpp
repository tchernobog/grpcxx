#include "grpcxx.h"

#include <fmt/core.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/io/zero_copy_stream.h>

#include <cstddef>
#include <memory>
#include <string>

bool Grpcxx::Generate(
	const google::protobuf::FileDescriptor *file, const std::string &parameter,
	google::protobuf::compiler::GeneratorContext *context, std::string *error) const {

	std::string output = fmt::format(
		R"(// Code generated by {0}.
// Versions:
//   - {0}: v{1}
// Source: {2}

#pragma once

#include <grpcxx/client.h>
#include <grpcxx/rpc.h>
#include <grpcxx/service.h>

#include "{3}"

)",
		PLUGIN_NAME,
		PLUGIN_VERSION,
		file->name(),
		google::protobuf::compiler::StripProto(file->name()) + ".pb.h");

	std::string ns = ReplaceString(file->package(), ".", "::");

	// Output optional namespace
	if (!ns.empty()) {
		output += fmt::format("namespace {} {{\n\n", ns);
	}

	GenerateService(file, parameter, context, error, output);
	GenerateClientStub(file, parameter, context, error, output);

	// Close namespace if needed
	if (!ns.empty()) {
		output += fmt::format("}} // ~ namespace {}\n", ns);
	}

	std::unique_ptr<google::protobuf::io::ZeroCopyOutputStream> ostream(
		context->Open(google::protobuf::compiler::StripProto(file->name()) + ".grpcxx.pb.h"));

	google::protobuf::io::CodedOutputStream costream(ostream.get());
	costream.WriteRaw(output.data(), output.size());

	return true;
}

bool Grpcxx::GenerateService(
	const google::protobuf::FileDescriptor *file, const std::string &parameter,
	google::protobuf::compiler::GeneratorContext *context, std::string *error,
	std::string &output) const {

	for (int i = 0; i < file->service_count(); i++) {
		auto service  = file->service(i);
		output       += fmt::format("namespace {} {{\n\n", service->name());

		std::string tmp = fmt::format(
			"using Service = grpcxx::service<\"{}{}{}\"",
			file->package(),
			file->package().empty() ? "" : ".",
			service->name());

		for (int j = 0; j < service->method_count(); j++) {
			auto method  = service->method(j);
			output      += fmt::format(
                "using rpc{0} = grpcxx::rpc<\"{0}\", {1}, {2}>;\n\n",
                method->name(),
                MapToCppType(file, method->input_type()),
                MapToCppType(file, method->output_type()));

			tmp += fmt::format(", rpc{}", method->name());
		}

		output += tmp + ">;\n\n";

		output += R"(struct ServiceImpl {
	template <typename T>
	typename T::result_type call(grpcxx::context &, const typename T::request_type &) {
		return {grpcxx::status::code_t::unimplemented, std::nullopt};
	}
};

)";
		output += fmt::format("}} // ~ namespace {}\n", service->name());
	}

	return true;
}

bool Grpcxx::GenerateClientStub(
	const google::protobuf::FileDescriptor *file, const std::string &parameter,
	google::protobuf::compiler::GeneratorContext *context, std::string *error,
	std::string &output) const {

	for (int i = 0; i < file->service_count(); i++) {
		auto              service           = file->service(i);
		const std::string client_class_name = service->name() + "Client";

		std::string methods;
		for (int j = 0; j < service->method_count(); j++) {
			auto method = service->method(j);

			const std::string rpc_name = fmt::format("{}::rpc{}", service->name(), method->name());
			std::string       input_type;
			if (method->client_streaming()) {
				input_type = fmt::format("stream<typename {}::request_type>", rpc_name);
			} else {
				input_type = fmt::format("typename {}::request_type", rpc_name);
			}

			std::string return_type;
			if (method->server_streaming()) {
				return_type = fmt::format("stream<typename {}::response_type>", rpc_name);
			} else {
				return_type = fmt::format("typename {}::result_type", rpc_name);
			}

			std::string delegate = "send";
			if (method->server_streaming() && method->client_streaming()) {
				delegate = "send_bidi";
			} else if (method->server_streaming() || method->client_streaming()) {
				delegate = "send_stream";
			}

			methods += fmt::format(
				R"(
	[[nodiscard]]
	auto {0}(const {1}& req) 
		-> {2}
	{{ 
		return {3}<{4}>(req); 
	}}
	)",
				method->name(),
				input_type,
				return_type,
				delegate,
				rpc_name);
		}

		// Output the class definitionq
		output += fmt::format(
			R"(
class {} : public ::grpcxx::client {{
public:
	// Methods
{}
}}; // ~ class {}

)",
			client_class_name,
			methods,
			client_class_name);
	}

	return true;
}

auto Grpcxx::MapToCppType(
	const google::protobuf::FileDescriptor *file, const google::protobuf::Descriptor *t)
	-> std::string {

	// Map proto types to c++ types
	// e.g. `google.protobuf.Empty` -> `google::protobuf::Empty`
	auto name = t->full_name();
	if (!file->package().empty() && name.starts_with(file->package())) {
		name = name.substr(file->package().size() + 1);
	}

	return ReplaceString(name, ".", "::");
}

auto Grpcxx::ReplaceString(std::string input, std::string_view search, std::string_view replace)
	-> std::string {
	std::size_t start = 0;
	while ((start = input.find(search, start)) != std::string::npos) {
		input.replace(start, search.size(), replace);
		start += search.size();
	}

	return input;
}
